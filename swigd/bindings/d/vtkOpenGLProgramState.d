/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.0
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

module vtkOpenGLProgramState;

static import vtkd_im;
static import core.stdc.config;

static import std.conv;
static import std.string;

static import std.conv;
static import std.string;
static import SWIGTYPE_p_ostream;
static import vtkIndent;
static import SWIGTYPE_p_GLuint;
static import SWIGTYPE_p_GLboolean;
static import SWIGTYPE_p_GLint;
static import SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t;
static import SWIGTYPE_p_vtkgl__GLchar;

class vtkOpenGLProgramState {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(vtkOpenGLProgramState obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin vtkd_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          vtkd_im.delete_vtkOpenGLProgramState(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  public void PrintSelf(SWIGTYPE_p_ostream.SWIGTYPE_p_ostream os, vtkIndent.vtkIndent indent) {
    vtkd_im.vtkOpenGLProgramState_PrintSelf(cast(void*)swigCPtr, SWIGTYPE_p_ostream.SWIGTYPE_p_ostream.swigGetCPtr(os), vtkIndent.vtkIndent.swigGetCPtr(indent));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public void Id(SWIGTYPE_p_GLuint.SWIGTYPE_p_GLuint value) @property {
    vtkd_im.vtkOpenGLProgramState_Id_set(cast(void*)swigCPtr, SWIGTYPE_p_GLuint.SWIGTYPE_p_GLuint.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLuint.SWIGTYPE_p_GLuint Id() @property const {
    SWIGTYPE_p_GLuint.SWIGTYPE_p_GLuint ret = new SWIGTYPE_p_GLuint.SWIGTYPE_p_GLuint(vtkd_im.vtkOpenGLProgramState_Id_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void DeleteStatus(SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean value) @property {
    vtkd_im.vtkOpenGLProgramState_DeleteStatus_set(cast(void*)swigCPtr, SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean DeleteStatus() @property const {
    SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean ret = new SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean(vtkd_im.vtkOpenGLProgramState_DeleteStatus_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void LinkStatus(SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean value) @property {
    vtkd_im.vtkOpenGLProgramState_LinkStatus_set(cast(void*)swigCPtr, SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean LinkStatus() @property const {
    SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean ret = new SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean(vtkd_im.vtkOpenGLProgramState_LinkStatus_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void ValidateStatus(SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean value) @property {
    vtkd_im.vtkOpenGLProgramState_ValidateStatus_set(cast(void*)swigCPtr, SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean ValidateStatus() @property const {
    SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean ret = new SWIGTYPE_p_GLboolean.SWIGTYPE_p_GLboolean(vtkd_im.vtkOpenGLProgramState_ValidateStatus_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void NumberOfAttachedShaders(SWIGTYPE_p_GLint.SWIGTYPE_p_GLint value) @property {
    vtkd_im.vtkOpenGLProgramState_NumberOfAttachedShaders_set(cast(void*)swigCPtr, SWIGTYPE_p_GLint.SWIGTYPE_p_GLint.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLint.SWIGTYPE_p_GLint NumberOfAttachedShaders() @property const {
    SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ret = new SWIGTYPE_p_GLint.SWIGTYPE_p_GLint(vtkd_im.vtkOpenGLProgramState_NumberOfAttachedShaders_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void InfoLogLength(SWIGTYPE_p_GLint.SWIGTYPE_p_GLint value) @property {
    vtkd_im.vtkOpenGLProgramState_InfoLogLength_set(cast(void*)swigCPtr, SWIGTYPE_p_GLint.SWIGTYPE_p_GLint.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLint.SWIGTYPE_p_GLint InfoLogLength() @property const {
    SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ret = new SWIGTYPE_p_GLint.SWIGTYPE_p_GLint(vtkd_im.vtkOpenGLProgramState_InfoLogLength_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void ActiveUniforms(SWIGTYPE_p_GLint.SWIGTYPE_p_GLint value) @property {
    vtkd_im.vtkOpenGLProgramState_ActiveUniforms_set(cast(void*)swigCPtr, SWIGTYPE_p_GLint.SWIGTYPE_p_GLint.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ActiveUniforms() @property const {
    SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ret = new SWIGTYPE_p_GLint.SWIGTYPE_p_GLint(vtkd_im.vtkOpenGLProgramState_ActiveUniforms_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void ActiveUniformMaxLength(SWIGTYPE_p_GLint.SWIGTYPE_p_GLint value) @property {
    vtkd_im.vtkOpenGLProgramState_ActiveUniformMaxLength_set(cast(void*)swigCPtr, SWIGTYPE_p_GLint.SWIGTYPE_p_GLint.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ActiveUniformMaxLength() @property const {
    SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ret = new SWIGTYPE_p_GLint.SWIGTYPE_p_GLint(vtkd_im.vtkOpenGLProgramState_ActiveUniformMaxLength_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void ActiveAttributes(SWIGTYPE_p_GLint.SWIGTYPE_p_GLint value) @property {
    vtkd_im.vtkOpenGLProgramState_ActiveAttributes_set(cast(void*)swigCPtr, SWIGTYPE_p_GLint.SWIGTYPE_p_GLint.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ActiveAttributes() @property const {
    SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ret = new SWIGTYPE_p_GLint.SWIGTYPE_p_GLint(vtkd_im.vtkOpenGLProgramState_ActiveAttributes_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void ActiveAttributeMaxLength(SWIGTYPE_p_GLint.SWIGTYPE_p_GLint value) @property {
    vtkd_im.vtkOpenGLProgramState_ActiveAttributeMaxLength_set(cast(void*)swigCPtr, SWIGTYPE_p_GLint.SWIGTYPE_p_GLint.swigGetCPtr(value));
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
  }

  public SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ActiveAttributeMaxLength() @property const {
    SWIGTYPE_p_GLint.SWIGTYPE_p_GLint ret = new SWIGTYPE_p_GLint.SWIGTYPE_p_GLint(vtkd_im.vtkOpenGLProgramState_ActiveAttributeMaxLength_get(cast(void*)swigCPtr), true);
    if (vtkd_im.SwigPendingException.isPending) throw vtkd_im.SwigPendingException.retrieve();
    return ret;
  }

  public void AttachedShaders(SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t.SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t value) @property {
    vtkd_im.vtkOpenGLProgramState_AttachedShaders_set(cast(void*)swigCPtr, SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t.SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t.swigGetCPtr(value));
  }

  public SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t.SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t AttachedShaders() @property const {
    void* cPtr = vtkd_im.vtkOpenGLProgramState_AttachedShaders_get(cast(void*)swigCPtr);
    SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t.SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t ret = (cPtr is null) ? null : new SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t.SWIGTYPE_p_std__vectorT_vtkOpenGLShaderState_t(cPtr, false);
    return ret;
  }

  public void InfoLog(SWIGTYPE_p_vtkgl__GLchar.SWIGTYPE_p_vtkgl__GLchar value) @property {
    vtkd_im.vtkOpenGLProgramState_InfoLog_set(cast(void*)swigCPtr, SWIGTYPE_p_vtkgl__GLchar.SWIGTYPE_p_vtkgl__GLchar.swigGetCPtr(value));
  }

  public SWIGTYPE_p_vtkgl__GLchar.SWIGTYPE_p_vtkgl__GLchar InfoLog() @property const {
    void* cPtr = vtkd_im.vtkOpenGLProgramState_InfoLog_get(cast(void*)swigCPtr);
    SWIGTYPE_p_vtkgl__GLchar.SWIGTYPE_p_vtkgl__GLchar ret = (cPtr is null) ? null : new SWIGTYPE_p_vtkgl__GLchar.SWIGTYPE_p_vtkgl__GLchar(cPtr, false);
    return ret;
  }

  public void HasVertexShader(bool value) @property {
    vtkd_im.vtkOpenGLProgramState_HasVertexShader_set(cast(void*)swigCPtr, value);
  }

  public bool HasVertexShader() @property const {
    bool ret = vtkd_im.vtkOpenGLProgramState_HasVertexShader_get(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public void HasFragmentShader(bool value) @property {
    vtkd_im.vtkOpenGLProgramState_HasFragmentShader_set(cast(void*)swigCPtr, value);
  }

  public bool HasFragmentShader() @property const {
    bool ret = vtkd_im.vtkOpenGLProgramState_HasFragmentShader_get(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public this() {
    this(vtkd_im.new_vtkOpenGLProgramState(), true);
  }
}
